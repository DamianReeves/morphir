// Generated by `wit-bindgen` 0.21.0. DO NOT EDIT!
// Options used:
pub mod morphir_ir {
    pub mod name {
        #[allow(clippy::all)]
        pub mod name {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub enum Run {
                Run(_rt::String),
            }
            impl ::core::fmt::Debug for Run {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Run::Run(e) => f.debug_tuple("Run::Run").field(e).finish(),
                    }
                }
            }
            #[derive(Clone)]
            pub enum Name {
                Name(_rt::Vec<Run>),
            }
            impl ::core::fmt::Debug for Name {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Name::Name(e) => f.debug_tuple("Name::Name").field(e).finish(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn from_string(input: &str) -> Name {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let vec0 = input;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "morphir-ir:name/name@0.1.0")]
                    extern "C" {
                        #[link_name = "from-string"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1);
                    let l2 = i32::from(*ptr1.add(0).cast::<u8>());
                    let v11 = match l2 {
                        n => {
                            debug_assert_eq!(n, 0, "invalid enum discriminant");
                            let e11 = {
                                let l3 = *ptr1.add(4).cast::<*mut u8>();
                                let l4 = *ptr1.add(8).cast::<usize>();
                                let base10 = l3;
                                let len10 = l4;
                                let mut result10 = _rt::Vec::with_capacity(len10);
                                for i in 0..len10 {
                                    let base = base10.add(i * 12);
                                    let e10 = {
                                        let l5 = i32::from(*base.add(0).cast::<u8>());
                                        let v9 = match l5 {
                                            n => {
                                                debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                let e9 = {
                                                    let l6 = *base.add(4).cast::<*mut u8>();
                                                    let l7 = *base.add(8).cast::<usize>();
                                                    let len8 = l7;
                                                    let bytes8 = _rt::Vec::from_raw_parts(
                                                        l6.cast(),
                                                        len8,
                                                        len8,
                                                    );

                                                    _rt::string_lift(bytes8)
                                                };
                                                Run::Run(e9)
                                            }
                                        };

                                        v9
                                    };
                                    result10.push(e10);
                                }
                                _rt::cabi_dealloc(base10, len10 * 12, 4);

                                result10
                            };
                            Name::Name(e11)
                        }
                    };
                    v11
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn to_string(name: &Name) -> _rt::String {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let (result2_0, result2_1, result2_2) = match name {
                        Name::Name(e) => {
                            let vec1 = e;
                            let len1 = vec1.len();
                            let layout1 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec1.len() * 12, 4);
                            let result1 = if layout1.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout1);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec1.into_iter().enumerate() {
                                let base = result1.add(i * 12);
                                {
                                    match e {
                                        Run::Run(e) => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                            let vec0 = e;
                                            let ptr0 = vec0.as_ptr().cast::<u8>();
                                            let len0 = vec0.len();
                                            *base.add(8).cast::<usize>() = len0;
                                            *base.add(4).cast::<*mut u8>() = ptr0.cast_mut();
                                        }
                                    }
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result1, layout1)]);

                            (0i32, result1, len1)
                        }
                    };
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "morphir-ir:name/name@0.1.0")]
                    extern "C" {
                        #[link_name = "to-string"]
                        fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(result2_0, result2_1, result2_2, ptr3);
                    let l4 = *ptr3.add(0).cast::<*mut u8>();
                    let l5 = *ptr3.add(4).cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    _rt::string_lift(bytes6)
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.21.0:app:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 288] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xa6\x01\x01A\x02\x01\
A\x02\x01B\x09\x01q\x01\x03run\x01s\0\x04\0\x03run\x03\0\0\x01p\x01\x01q\x01\x04\
name\x01\x02\0\x04\0\x04name\x03\0\x03\x01@\x01\x05inputs\0\x04\x04\0\x0bfrom-st\
ring\x01\x05\x01@\x01\x04name\x04\0s\x04\0\x09to-string\x01\x06\x03\x01\x1amorph\
ir-ir:name/name@0.1.0\x05\0\x04\x01\x19morphir-ir:name/app@0.1.0\x04\0\x0b\x09\x01\
\0\x03app\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.\
201.0\x10wit-bindgen-rust\x060.21.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
